## hash函数

1.输入域无穷大,输出域有穷尽(不同的输入可能会导致相同的输出 --hash碰撞).
2.输入参数不变时,返回值固定.
3.**样本量足够大**时,在整个输出域均匀分布(离散性).
4.与输入规律无关(散列 --打乱数据结构).
5.如果在0~m上均匀分布,0~s上也会均匀分布(结果模上一个数,会相应的缩减输出域).

## hash表的具体实现

使用一张表来存储生成的hashCode,如果发生了hash碰撞,就在其后挂一个链表.
链表遍历并不是O(1),如果太长会影响整体的时间复杂度.因此,当链表到达一定长度后
(链表长度>8 && 数组大小>=64), 会变成一个红黑树.
如果hash这个表太小,碰撞的概率就会不断上升,需要扩容 --重新计算并分配hash表.

HashMap是怎么保证O(1)的增删改查呢?
按最简单的结构考虑,假设hash表的链表超过一个就得扩容.假设初始大小为n,hash扩容k次的时间复杂度是:

1. m * 2
2. m * (2 ^ 2)
3. m * (2 ^ k)

根据等比数列求和公式, 也就是 m * (2^k - 1).
当 HashMap 的初始容量和负载因子选择得当时,扩容的次数是有限的,因此多次扩容的时间复杂度可以看作是常数级别的.

## 避免hash冲突的方式

1. 较低的填充因子;
   填充因子 = hash表包含的元素数 / 位置总数
   一旦填充因子超过0.7 ,就应该重新调整散列表的长度.
2. 良好的hash函数(SHA函数).
   SHA (Secure Hash Algorithm) 是一种加密哈希函数，用于将数据转换为固定长度的消息摘要。

## hash常见应用

1. hash表防止重复, 统计次数.
2. DNS解析:将网站名映射成实际的ip地址.
   DNS（Domain Name System）是一种分布式数据库系统，用于将域名转换为IP地址以便客户端可以使用易于记忆的域名来访问网络资源，而无需记住复杂的IP地址。
   为了实现DNS映射，需要维护一个存储域名和对应IP地址之间映射关系的数据库。在实际应用中，DNS数据库通常使用哈希表来实现。
   具体来说,在DNS映射中,每个域名可以作为哈希表的键,对应的IP地址可以作为哈希表的值.
   当客户端向DNS服务器查询某个域名的IP地址时,DNS服务器会在其哈希表中查找相应的映射关系并将结果返回给客户端.
   如果哈希表中没有找到相应的映射关系,则DNS服务器可能需要向其他DNS服务器发起递归查询,以便找到相应的IP地址.
3. 将hash表用作缓存.
   Redis本身就是一个大的哈希结构.Redis使用哈希表作为内部数据结构来存储所有的键值对数据.
   具体来说,Redis将所有的键值对数据都存储在一个全局的哈希表中,这个哈希表被称为字典.Redis的字典使用哈希表作为底层实现,
   可以高效地支持数据的插入、查找和删除操作，同时可以扩展到非常大的数据规模。
   每个键值对数据在Redis中都对应着一个唯一的键,可以通过键来进行数据的访问和操作.
   在Redis中，使用"HSET"命令来添加或修改键值对数据，使用"HGET"命令来获取指定键对应的值，使用"HDEL"命令来删除指定键对应的键值对数据。

### hash分流

Q:如何给一个100T的大文件去重?

1. 先问有没有多台机器,如果有1000台,好,可以分流;
2. 有没有**分布式文件系统(HDFS)**? 有,好,不用担心读取的效率.
3. 把每一行读取出来,hashCode() % 1000,分到不同的机器.
4. 不同的字符串会相对均匀地分到1000台机器上,**相同的字符串一定会分到同一台机器上**.
5. 每台机器还可以开多个线程,递归的去分流.

## 一致性哈希

### 经典服务器抗压结构:

1. 会有专门一个前端服务器(nginx/tomcat),当请求过来的时候,前端服务器的多个service都是相同的hash().
2. 根据hashCode取模之后,根据hashcode去找下面指定的服务器.
   (A经过hash之后存入001机器,后续A的请求都是会到001 --hash的性质).
   因为hash函数的离散性,每个服务器处理的请求应是大致均匀的.因此,每个服务器负载均衡.
   缺陷:
   调整服务器的个数时,所有的数据归属都会相应的改变(原理类似于hash表的扩容).

### 一致性哈希的目的就是把数据迁移的代价调低.

1. 把整个hash函数的返回值当做一个圈来处理,将服务器的hashCode进行排序,分布在环上.
2. hashcode打在环上之后,按顺时针的方向找,找到的第一个服务器就是要处理这个请求的服务器.
3. 这样的话,新添加一个服务器时,计算出来它在环上的位置后. 原本是:A -> B,现状:A -> C -> B
4. 这样只需要迁移A -> C的部分即可.

缺陷:

1. hash的特性是量在多的情况下才会被均匀分布,如果服务器数量比较小,不一定能被均匀分布.
2. 如果几个服务器距离很近的话,负载均衡会成问题.

在虚拟节点技术中,每个物理节点会被映射到多个虚拟节点上,每个虚拟节点都对应着一个哈希值.
当需要存储一个新的数据时,先将其哈希到一个虚拟节点上,然后再将这个数据存储到对应的物理节点上.
这样每个物理节点上都会存储多个虚拟节点对应的数据,从而实现了数据的分片和负载均衡.
虚拟节点技术一般包含以下几个步骤：

1. 确定物理节点数量：首先需要确定系统中物理节点的数量，即分片的目标节点数。这通常是在系统设计或部署时确定的。
2. 生成虚拟节点：针对每个物理节点，生成一定数量的虚拟节点，通常是使用哈希算法对节点名称进行计算得到的。
3. 构建哈希环：将所有的虚拟节点按照哈希值大小顺序排成一个哈希环，如一致性哈希算法中的环。
4. 映射数据：当需要存储一个新的数据时，首先使用hash算法将其映射到一个虚拟节点上(顺时针方向找)，然后将这个数据存储到对应的物理节点上。
5. 添加或删除节点：当需要添加或删除一个物理节点时，只需要重新计算该节点对应的所有虚拟节点的哈希值，并将这些虚拟节点重新加入哈希环或从哈希环中移除即可。

## 位图

节省空间,基础类型来拼接

## 布隆过滤器 -百亿黑名单设计

Q:有一个100亿的url名单,要求是访问到这个名单里的url时,返回错误信息.

1. 以一个正常的Map来存储,需要100亿条数据(每条还可能占用较多的字节).能实现,但是耗费内存.
2. 考虑采用布隆过滤器来优化存储空间,准备一个M长度的bit类型的标记数组.
3. M 要选用多大的(向上取整)?
   N: 样本量
   P: 预期失误率
   M = - N*lnP / (ln2)^2
4. K 要选用多大?
   对于每条数据分别用 K 个哈希函数计算并对 M(数组长度) 取模,然后将这几个位置描黑.
   K = ln2 * M/N = 0.7 * M/N
5. 判断是否为黑名单中的数据时,只需要计算这个url,查找数组中对应的 K 个位置是否全部被描黑.
   只要有一个位置没黑,当前url就不是黑名单中的数据.

### 为什么有失误率呢?

黑名单中的url肯定 K 个位置都是黑的;
如果 M 开的比较小,会存在干净的url,但是它的 K 个位置全被其他的计算值涂满了.

### 失误率的计算

前两个步骤都存在根据实际情况调整的过程: 比如M算出来1000万,发现目前可以利用空间有1500万,
也是可以调大 M 来降低失误率的.
但是无论 M 开的多大,还是会有失误率的,hash就是有碰撞概率.

同样的,如果只有一个hash函数,失误率相对会比较大(一个位置被黑就认为是黑名单了).
(1 - e^-(N*K/M))^K
但是,如果 K 选的特别多,失误率也会上升.

### hash函数的选用

在理论上使用一个哈希函数可以通过不同的方式创建出多个哈希函数,
例如将输入的数据切分为不同的部分,然后对每个部分分别进行哈希运算,最后将每个部分的哈希值合并为一个综合的哈希值.
这种方式通常被称为哈希函数族.

1. 1*f1(1) + f2(1)
2. 2*f1(1) + f2(1)
3. 3*f1(1) + f2(1)
   ....
   都是几乎独立的

然而在实践中使用一个哈希函数来创建多个哈希函数是不太可行的,因为哈希函数设计时需要考虑多个因素,
例如哈希值的均匀分布、哈希冲突的概率等等,这些因素会影响哈希函数的性能和可靠性.
因此为了满足不同的需求,通常需要设计不同的哈希函数,或者使用已有的高质量哈希函数库来实现不同的哈希函数.

### 实际使用

HDFS过程中,每个块都维持一个自己的布隆过滤器,拿到一个id时直接访问布隆过滤器来确定在哪个块中.

## 资源限制类问题总结

1）hash可以把数据按照种类均匀分流,相同值的一定会分在一起(分段统计)
2）利用堆、外排序来做多个处理单元的结果合并
3）布隆过滤器可以在节省大量空间的情况下,找出当前访问元素在不在集合中(有失误率)
4）一致性哈希解决hash分流时的不均匀情况(服务器太少,数据量小)
5）利用并查集结构做岛问题的并行计算
6）位图可以在节省大量空间的情况下,解决某一范围上数字的出现情况

## hash算法的选择

MD5和Java自带的hashCode()是两种不同的哈希算法，它们的设计目的也不同。
MD5（Message Digest Algorithm
5）是一种广泛使用的密码散列函数，用于产生散列值（哈希值）以及对数据的完整性进行验证。它可以将任意长度的消息转换为128位的哈希值，该哈希值具有高度的随机性和不可逆性，即使在输入消息稍微变化的情况下，输出的哈希值也会有很大的变化。因此，MD5通常用于密码学安全场景，如验证用户密码或数字签名等。
而Java自带的hashCode()方法是一种简单的哈希算法，用于将Java对象转换为整数值。hashCode()
方法返回的值是基于对象的内部状态计算出来的，并且具有相同内部状态的对象应该返回相同的hashCode()
值，以便它们可以在哈希表中进行正确的查找和比较。hashCode()方法通常用于Java集合类中的哈希表实现，如HashMap和HashSet。
因此，MD5和hashCode()的应用场景和设计目的是不同的。MD5更适用于安全领域，而hashCode()更适用于哈希表实现。
MessageDigest类为应用程序提供信息摘要算法的功能,如MD5或SHA算法.
信息摘要是安全的单向哈希函数,它接收任意大小的数据,输出固定长度的哈希值.
java自带的hashcode,表达的范围是2^32次方,如果只要正数的话就是2^31 - 1