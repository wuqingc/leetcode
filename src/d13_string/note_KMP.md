字符串查找算法:求一个字符串(A)中是否包含另一个字符串(B).

常规算法:遍历两个字符串进行比较,遇到不匹配的情况时,长串指针移动到下一位重新比较即可.
时间复杂度:O(A.length*B.length)

KMP:使用常规解法时,前面的遍历信息不会被保存,每次都是移动位置后重新遍历(dp思想).
要是能够可以把每次遍历之后的信息都存储起来,就可以在下次遍历之前使用来优化时间复杂度(空间换时间).

空间:求取B串的每个字符前面的字符串的最长匹配长度(前缀=后缀),将其存在一个next数组中.
规定:前缀不取最后一个字符,后缀不取第一个字符(无意义);
     前面没有字符串时  -1
     只有一个字符时    0
如何求解next数组?
数学归纳法:判断当前的字符的前一个字符的最长前缀的后一个字符是否等于当前字符.
          如果相等,最长匹配长度 = 前一个字符的最长匹配长度 + 1
          不相等时,继续递归.
例:ababcabab t k(已知t的最长前缀为abab,求k)
1.c != t 进行递归
2.ababc(最长前缀为ab)
3.a != t 进行递归
4.ab a(不存在匹配,直接返回0)
如果有相等的情况,就是当前字串的最长匹配长度 + 1.

如何使用next数组加速?
str1: i...k..j...2
str2: 0...k..j...3

2 != 3时(j...为最长后缀):
i...k..j...2
       0...k..j...3
直接跳过前面几个位置的比较

为什么可以直接跳过?
假设存在k,可以完成匹配:
i...k..j...2
    0...k..j...3

可以推出在str2中:k..j... == 0...k..
最长后缀为k..j...而不是j...,与已知结论不符合.


- [ ]  为什么e位置前面配不出来了
- [ ]  假设一个位置能配出来 那么最长前缀就是当前位置 与已知最长冲突
- [ ]  如果就是最长前缀中的一个能配出来 那e前面那几个也都是相等的
- [ ]  其实就是回到了最长前缀的位置 只不过又省了最长前缀